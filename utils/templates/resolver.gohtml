{{/* The line below tells Intellij/GoLand to enable the autocompletion based on the *gen.Graph type. */}}
{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "resolvers/resolver" }}

{{/* Add the base header for the generated file */}}
{{/*{{ template "header" $ }}*/}}

// Code generated by utils/templates, DO NOT EDIT.

package resolvers

import (
    "context"
    "errors"
    "encoding/json"
    "log/slog"
    "project/custom"
    "project/ent"
    "project/utils/apm"
    "github.com/RichardKnop/machinery/v2/tasks"
    "project/utils/taskQueue"

{{ range $node := $.Nodes }}    "project/ent/{{ $node.Name | lower }}"
{{end}}

    "project/schema"
    "project/utils/db"
    "project/utils/jwt"

    "entgo.io/contrib/entgql"
    "github.com/99designs/gqlgen/graphql"
    "github.com/google/uuid"
    "github.com/xuri/excelize/v2"
    "project/utils/upload"
    "project/utils/random"
)

func init() {
    var err error
{{ range $node := $.Nodes }}
    err = taskQueue.Server.RegisterTask("{{ $node.Name }}ExportTask", {{ $node.Name }}ExportTask)
    if err != nil {
        slog.Error("Error registering {{ $node.Name }}ExportTask", "error", err)
    }
{{end}}

}
type OrderByDirectionField struct {
    Direction string
    Field     string
}

// Resolver is the resolver root.
type Resolver struct{
    client *ent.Client
    *custom.GqlResolver
}

// NewSchema creates a graphql executable schema.
func NewSchema(client *ent.Client) graphql.ExecutableSchema {
    return NewExecutableSchema(Config{
        Resolvers: &Resolver{client: client},
    })
}
type queryResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }

func (r *Resolver) Query() QueryResolver       { return &queryResolver{r} }
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

func (r queryResolver) Node(ctx context.Context, id uuid.UUID) (ent.Noder, error) {
    return r.client.Noder(ctx, id)
}

func (r queryResolver) Nodes(ctx context.Context, ids []uuid.UUID) ([]ent.Noder, error) {
    return r.client.Noders(ctx, ids)
}

func getJwtUser(ctx context.Context) (*ent.User, error) {
    userId, err := jwt.GetCurrentJwtUserID(ctx)
    if err != nil {
        slog.Debug("resolver getJwtUser", "err", err)
        return nil, err
    }
    return getJwtUserById(ctx, userId)
}

func getJwtUserById(ctx context.Context, userId *string) (*ent.User, error) {
    userUUID, err := uuid.Parse(*userId)
    if err != nil {
        return nil, err
    }
    user, err := db.Client.User.Query().Where(user.IDEQ(userUUID), user.IsDisabledEQ(false)).First(ctx)
    if err != nil {
        slog.Debug("resolver db.Client.User.Query() ->", "err", err)
        return nil, errors.New("user is Disabled")
    }
    userCompany , err := user.Company(ctx)
    if err != nil {
        return nil, err
    }

    if userCompany.IsDisabled {
        return nil, errors.New("company is Disabled")
    }
    return user, nil
}

{{ range $node := $.Nodes }}

func (r *Resolver) {{ $node.QueryName }}(
    ctx context.Context,
    after *entgql.Cursor[uuid.UUID],
    first *int,
    before *entgql.Cursor[uuid.UUID],
    last *int,
    orderBy []*ent.{{ $node.Name }}Order,
    where *ent.{{ $node.Name }}WhereInput,
) (*ent.{{ $node.Name }}Connection, error) {
    if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
        resolverName.Names = append(resolverName.Names, "{{ $node.QueryName }}")
    }
    resource := schema.{{ $node.Name }}{}.Resource()
    if resource.HasReadPermission == nil {
        return nil, errors.New("Has no read permission")
    } else {
        var jwtUser *ent.User
        var err error
        if ! resource.SkipJWTCheck {
jwtUser, err = getJwtUser(ctx)
            if err != nil {
                slog.Debug("{{ $node.QueryName }} getJwtUser", "err", err)
                return nil, err
            }
        }

        qs := r.client.{{ $node.Name }}.Query()
        err = resource.HasReadPermission(ctx, jwtUser, qs)
        if err != nil {
            slog.Debug("{{ $node.QueryName }}", "err", err)
            return nil, err
        }
        return qs.Paginate(ctx, after, first, before, last, ent.With{{ $node.Name }}Filter(where.Filter), ent.With{{ $node.Name }}Order(orderBy))
    }
}

type {{ $node.Name }}ExportTaskInput struct {
    After *entgql.Cursor[uuid.UUID]
    First *int
    Before *entgql.Cursor[uuid.UUID]
    Last *int
    OrderBy []OrderByDirectionField
    Where *ent.{{ $node.Name }}WhereInput
    FileType string
    ExcelUrl *string
    UserId *string
}

func {{ $node.Name }}ExportTask(
    ctx context.Context,
    input string,
) (string, error) {

    var taskInput {{ $node.Name }}ExportTaskInput

    err := json.Unmarshal([]byte(input), &taskInput)
    if err != nil {
        return "", err
    }

    resource := schema.{{ $node.Name }}{}.Resource()
    if resource.HasReadPermission == nil {
        return "", errors.New("Has no read permission")
    }

    if resource.ExportRow == nil {
        return "", errors.New("Has no export row formatter")
    }



    var jwtUser *ent.User
    if !resource.SkipJWTCheck {
        jwtUser, err = getJwtUserById(ctx, taskInput.UserId)
        if err != nil {
            slog.Debug("{{ $node.Name }}Query getJwtUser", "err", err)
            return "", err
        }
    }

    qs := db.Client.{{ $node.Name }}.Query()
    err = resource.HasReadPermission(ctx, jwtUser, qs)
    if err != nil {
        slog.Debug("{{ $node.Name }}Query", "err", err)
        return "", err
    }
    if resource.ExportPreload != nil {
        err = resource.ExportPreload(ctx, jwtUser, qs)
        if err != nil {
            slog.Debug("{{ $node.Name }}Query", "err", err)
            return "", err
        }
    }


    var orderBy []*ent.{{ $node.Name }}Order

    for _, order := range taskInput.OrderBy {
        f := ent.Default{{ $node.Name }}Order
        f.Direction = ent.OrderDirection(order.Direction)
        f.Field.UnmarshalGQL(order.Field)
        orderBy = append(orderBy, f)
    }

    rows, err := qs.Paginate(ctx, taskInput.After,
        taskInput.First,
        taskInput.Before,
        taskInput.Last,
        ent.With{{ $node.Name }}Filter(taskInput.Where.Filter),
        ent.With{{ $node.Name }}Order(orderBy),
    )

    workbook := excelize.NewFile()
    sheetName := "Sheet1"
    if workbook.SheetCount == 0 {
    _, err = workbook.NewSheet(sheetName)
    if err != nil {
        return "", err
    }
    } else {
        sheetName = workbook.GetSheetList()[0]
    }

    if resource.ExportHeaders != nil {
        for i, header := range resource.ExportHeaders {
            // Set value of a cell.
            workbook.SetCellValue(sheetName, fmt.Sprintf("%s%d", string(rune(65+i)), 1), header)
        }
    }

    rowIndex := 1

    for _, edge := range rows.Edges {
        row := resource.ExportRow(ctx, jwtUser, edge.Node)
        if len(row) == 0 {
            continue
        }
        rowIndex += 1
        for i, cell := range row {
            if reflect.ValueOf(cell).Kind().String() == "ptr" {
                if reflect.ValueOf(cell).IsNil() {
                    continue
                }
                cell = reflect.ValueOf(cell).Elem().Interface()
            }
            err = workbook.SetCellValue(sheetName, fmt.Sprintf("%s%d", string(rune(65+i)), rowIndex), cell)
            if err != nil {
                slog.Debug("{{ $node.Name }}ExportTask SetCellValue", "err", err)
            }
        }
    }

    fileName := "/tmp/" + random.Gen(10) + ".xlsx"

    err = workbook.SaveAs(upload.StaticDir + fileName)
    if err != nil {
        return "", err
    }

    if err := workbook.Close(); err != nil {
        slog.Error("{{ $node.Name }}ExportTask close workbook", "err", err)
    }

    return fileName, nil
}

func (r *Resolver) {{ $node.Name }}Export (
    ctx context.Context,
    after *entgql.Cursor[uuid.UUID],
    first *int,
    before *entgql.Cursor[uuid.UUID],
    last *int,
    orderBy []*ent.{{ $node.Name }}Order,
    where *ent.{{ $node.Name }}WhereInput,
    fileType string,
    excelUrl *string,
) (*string, error) {

    _, err := taskQueue.Server.GetRegisteredTask("{{ $node.Name }}ExportTask")
    if err != nil {
        return nil, err
    }

    var userId *string = nil

    resource := schema.{{ $node.Name }}{}.Resource()
    if resource.HasReadPermission == nil {
        return nil, errors.New("Has no read permission")
    }

    if resource.ExportRow == nil {
        return nil, errors.New("Has no export row formatter")
    }

    if !resource.SkipJWTCheck {
        userId, err = jwt.GetCurrentJwtUserID(ctx)
        if err != nil {
            slog.Debug("BottleQuery getJwtUser", "err", err)
            return nil, err
        }
    }

    taskInput := {{ $node.Name }}ExportTaskInput{
        After:    after,
        First:    first,
        Before:   before,
        Last:     last,
        Where:    where,
        FileType: fileType,
        ExcelUrl: excelUrl,
        UserId:   userId,
    }

    for _, order := range orderBy {
        taskInput.OrderBy = append(taskInput.OrderBy, OrderByDirectionField{
            Direction: order.Direction.String(),
            Field:     order.Field.String(),
        })
    }

    jsonBytes, err := json.Marshal(taskInput)
    if err != nil {
        return nil, err
    }

    s := tasks.Signature{
        Name: "{{ $node.Name }}ExportTask",
        Args: []tasks.Arg{
            {
                Type:  "string",
                Value: string(jsonBytes),
            },
        },
    }

    t := tasks.Signature(s)
    task, err := taskQueue.Server.SendTaskWithContext(ctx, &t)
    if err != nil {
        return nil, err
    }

    taskId := task.Signature.UUID
    return &taskId, nil
}




func (m mutationResolver) {{ $node.CreateName }}(ctx context.Context, input ent.Create{{ $node.Name }}Input) (*ent.{{ $node.Name }}, error) {
    if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
        resolverName.Names = append(resolverName.Names, "{{ $node.CreateName }}")
    }
    resource := schema.{{ $node.Name }}{}.Resource()
    if resource.HasCreatePermission == nil {
        return nil, errors.New("Has no create permission")
    } else {
        var jwtUser *ent.User
        var err error
        if !resource.SkipJWTCheck {
            jwtUser, err = getJwtUser(ctx)
            if err != nil {
                slog.Debug("{{ $node.CreateName }} getJwtUser", "err", err)
                return nil, err
            }
        }

        var inputs = []*ent.Create{{ $node.Name }}Input{&input}

        err = resource.HasCreatePermission(ctx, jwtUser, inputs)
        if err != nil {
            return nil, err
        }
        row, err := m.client.{{ $node.Name }}.Create().SetInput(input).Save(ctx)
        if err == nil && resource.AfterObjectSave != nil {
            go resource.AfterObjectSave(context.WithoutCancel(ctx), []*ent.{{ $node.Name }}{row}, jwtUser)
        }
        return row, err
    }
}

func (m mutationResolver) {{ $node.CreateBulkName }}(ctx context.Context, inputs []*ent.Create{{ $node.Name }}Input) ([]*ent.{{ $node.Name }}, error) {
    if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
        resolverName.Names = append(resolverName.Names, "{{ $node.CreateBulkName }}")
    }
    resource := schema.{{ $node.Name }}{}.Resource()
    if resource.HasCreatePermission == nil {
        return nil, errors.New("Has no create permission")
    } else {
        var jwtUser *ent.User
        var err error
        if !resource.SkipJWTCheck {
            jwtUser, err = getJwtUser(ctx)
            if err != nil {
                slog.Debug("{{ $node.CreateBulkName }} getJwtUser", "err", err)
                return nil, err
            }
        }

        err = resource.HasCreatePermission(ctx, jwtUser, inputs)
        if err != nil {
            slog.Debug("{{ $node.CreateBulkName }}", "err", err)
            return nil, err
        }
        rows, err := m.client.{{ $node.Name }}.MapCreateBulk(inputs, func(c *ent.{{ $node.Name }}Create, i int) {
            c.SetInput(*inputs[i])
        }).Save(ctx)
        if err == nil && resource.AfterObjectSave != nil {
            go resource.AfterObjectSave(context.WithoutCancel(ctx), rows, jwtUser)
        }
        return rows, err
    }
}

func (m mutationResolver) {{ $node.UpdateName }}(ctx context.Context, id uuid.UUID, input ent.Update{{ $node.Name }}Input) (*ent.{{ $node.Name }}, error) {
    if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
        resolverName.Names = append(resolverName.Names, "{{ $node.UpdateName }}")
    }
    resource := schema.{{ $node.Name }}{}.Resource()
    if resource.HasReadPermission == nil {
        return nil, errors.New("Has no read permission")
    }
    if resource.HasUpdatePermission == nil {
        return nil, errors.New("Has no update permission")
    }

    var jwtUser *ent.User
    var err error
    if ! resource.SkipJWTCheck {
        jwtUser, err = getJwtUser(ctx)
        if err != nil {
            return nil, err
        }
    }

    qs := m.client.{{ $node.Name }}.Query()
    err = resource.HasReadPermission(ctx, jwtUser, qs)
    if err != nil {
        return nil, err
    }

    row, err := qs.Where({{ $node.Name | lower }}.ID(id)).First(ctx)
    if err != nil {
        slog.Debug("{{ $node.UpdateName }} Where", "err", err)
        return nil, err
    }

    err = resource.HasUpdatePermission(ctx, jwtUser, row, &input)
    if err != nil {
        return nil, err
    }

    row, err = row.Update().SetInput(input).Save(ctx)
    if err == nil && resource.AfterObjectUpdate != nil {
        go resource.AfterObjectUpdate(context.WithoutCancel(ctx), row, jwtUser)
    }

    return row, err
}

func (m mutationResolver) {{ $node.DeleteName }}(ctx context.Context, id uuid.UUID) (*ent.{{ $node.Name }}, error) {
    if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
        resolverName.Names = append(resolverName.Names, "{{ $node.DeleteName }}")
    }
    resource := schema.{{ $node.Name }}{}.Resource()
    if resource.HasReadPermission == nil {
        return nil, errors.New("Has no read permission")
    }
    if resource.HasDeletePermission == nil {
        return nil, errors.New("Has no delete permission")
    }

    var jwtUser *ent.User
    var err error
    if ! resource.SkipJWTCheck {
        jwtUser, err = getJwtUser(ctx)
        if err != nil {
            return nil, err
        }
    }

    qs := m.client.{{ $node.Name }}.Query()
    err = resource.HasReadPermission(ctx, jwtUser, qs)
    if err != nil {
        return nil, err
    }

    row, err := qs.Where({{ $node.Name | lower }}.ID(id)).First(ctx)
    if err != nil {
        return nil, err
    }

    err = resource.HasDeletePermission(ctx, jwtUser, row)
    if err != nil {
        return nil, err
    }

    err = m.client.{{ $node.Name }}.DeleteOne(row).Exec(ctx)
    return row, err
}


{{ end }}


{{ end }}