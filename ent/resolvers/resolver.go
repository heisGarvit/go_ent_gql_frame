// Code generated by utils/templates, DO NOT EDIT.

package resolvers

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"project/custom"
	"project/ent"
	"project/utils/apm"
	"project/utils/taskQueue"
	"reflect"

	"github.com/RichardKnop/machinery/v2/tasks"

	"project/ent/company"
	"project/ent/permission"
	"project/ent/role"
	"project/ent/rolepermission"
	"project/ent/user"

	"project/schema"
	"project/utils/db"
	"project/utils/jwt"

	"project/utils/random"
	"project/utils/upload"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
	"github.com/xuri/excelize/v2"
)

func init() {
	var err error

	err = taskQueue.Server.RegisterTask("CompanyExportTask", CompanyExportTask)
	if err != nil {
		slog.Error("Error registering CompanyExportTask", "error", err)
	}

	err = taskQueue.Server.RegisterTask("PermissionExportTask", PermissionExportTask)
	if err != nil {
		slog.Error("Error registering PermissionExportTask", "error", err)
	}

	err = taskQueue.Server.RegisterTask("RoleExportTask", RoleExportTask)
	if err != nil {
		slog.Error("Error registering RoleExportTask", "error", err)
	}

	err = taskQueue.Server.RegisterTask("RolePermissionExportTask", RolePermissionExportTask)
	if err != nil {
		slog.Error("Error registering RolePermissionExportTask", "error", err)
	}

	err = taskQueue.Server.RegisterTask("UserExportTask", UserExportTask)
	if err != nil {
		slog.Error("Error registering UserExportTask", "error", err)
	}

}

type OrderByDirectionField struct {
	Direction string
	Field     string
}

// Resolver is the resolver root.
type Resolver struct {
	client *ent.Client
	*custom.GqlResolver
}

// NewSchema creates a graphql executable schema.
func NewSchema(client *ent.Client) graphql.ExecutableSchema {
	return NewExecutableSchema(Config{
		Resolvers: &Resolver{client: client},
	})
}

type queryResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }

func (r *Resolver) Query() QueryResolver       { return &queryResolver{r} }
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

func (r queryResolver) Node(ctx context.Context, id uuid.UUID) (ent.Noder, error) {
	return r.client.Noder(ctx, id)
}

func (r queryResolver) Nodes(ctx context.Context, ids []uuid.UUID) ([]ent.Noder, error) {
	return r.client.Noders(ctx, ids)
}

func getJwtUser(ctx context.Context) (*ent.User, error) {
	userId, err := jwt.GetCurrentJwtUserID(ctx)
	if err != nil {
		slog.Debug("resolver getJwtUser", "err", err)
		return nil, err
	}
	return getJwtUserById(ctx, userId)
}

func getJwtUserById(ctx context.Context, userId *string) (*ent.User, error) {
	userUUID, err := uuid.Parse(*userId)
	if err != nil {
		return nil, err
	}
	user, err := db.Client.User.Query().Where(user.IDEQ(userUUID), user.IsDisabledEQ(false)).First(ctx)
	if err != nil {
		slog.Debug("resolver db.Client.User.Query() ->", "err", err)
		return nil, errors.New("user is Disabled")
	}
	userCompany, err := user.Company(ctx)
	if err != nil {
		return nil, err
	}

	if userCompany.IsDisabled {
		return nil, errors.New("company is Disabled")
	}
	return user, nil
}

func (r *Resolver) CompanyQuery(
	ctx context.Context,
	after *entgql.Cursor[uuid.UUID],
	first *int,
	before *entgql.Cursor[uuid.UUID],
	last *int,
	orderBy []*ent.CompanyOrder,
	where *ent.CompanyWhereInput,
) (*ent.CompanyConnection, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "CompanyQuery")
	}
	resource := schema.Company{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("CompanyQuery getJwtUser", "err", err)
				return nil, err
			}
		}

		qs := r.client.Company.Query()
		err = resource.HasReadPermission(ctx, jwtUser, qs)
		if err != nil {
			slog.Debug("CompanyQuery", "err", err)
			return nil, err
		}
		return qs.Paginate(ctx, after, first, before, last, ent.WithCompanyFilter(where.Filter), ent.WithCompanyOrder(orderBy))
	}
}

type CompanyExportTaskInput struct {
	After    *entgql.Cursor[uuid.UUID]
	First    *int
	Before   *entgql.Cursor[uuid.UUID]
	Last     *int
	OrderBy  []OrderByDirectionField
	Where    *ent.CompanyWhereInput
	FileType string
	ExcelUrl *string
	UserId   *string
}

func CompanyExportTask(
	ctx context.Context,
	input string,
) (string, error) {

	var taskInput CompanyExportTaskInput

	err := json.Unmarshal([]byte(input), &taskInput)
	if err != nil {
		return "", err
	}

	resource := schema.Company{}.Resource()
	if resource.HasReadPermission == nil {
		return "", errors.New("Has no read permission")
	}

	if resource.ExportRow == nil {
		return "", errors.New("Has no export row formatter")
	}

	var jwtUser *ent.User
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUserById(ctx, taskInput.UserId)
		if err != nil {
			slog.Debug("CompanyQuery getJwtUser", "err", err)
			return "", err
		}
	}

	qs := db.Client.Company.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		slog.Debug("CompanyQuery", "err", err)
		return "", err
	}
	if resource.ExportPreload != nil {
		err = resource.ExportPreload(ctx, jwtUser, qs)
		if err != nil {
			slog.Debug("CompanyQuery", "err", err)
			return "", err
		}
	}

	var orderBy []*ent.CompanyOrder

	for _, order := range taskInput.OrderBy {
		f := ent.DefaultCompanyOrder
		f.Direction = ent.OrderDirection(order.Direction)
		f.Field.UnmarshalGQL(order.Field)
		orderBy = append(orderBy, f)
	}

	rows, err := qs.Paginate(ctx, taskInput.After,
		taskInput.First,
		taskInput.Before,
		taskInput.Last,
		ent.WithCompanyFilter(taskInput.Where.Filter),
		ent.WithCompanyOrder(orderBy),
	)

	workbook := excelize.NewFile()
	sheetName := "Sheet1"
	if workbook.SheetCount == 0 {
		_, err = workbook.NewSheet(sheetName)
		if err != nil {
			return "", err
		}
	} else {
		sheetName = workbook.GetSheetList()[0]
	}

	if resource.ExportHeaders != nil {
		for i, header := range resource.ExportHeaders {
			// Set value of a cell.
			workbook.SetCellValue(sheetName, fmt.Sprintf("%s%d", string(rune(65+i)), 1), header)
		}
	}

	rowIndex := 1

	for _, edge := range rows.Edges {
		row := resource.ExportRow(ctx, jwtUser, edge.Node)
		if len(row) == 0 {
			continue
		}
		rowIndex += 1
		for i, cell := range row {
			if reflect.ValueOf(cell).Kind().String() == "ptr" {
				if reflect.ValueOf(cell).IsNil() {
					continue
				}
				cell = reflect.ValueOf(cell).Elem().Interface()
			}
			err = workbook.SetCellValue(sheetName, fmt.Sprintf("%s%d", string(rune(65+i)), rowIndex), cell)
			if err != nil {
				slog.Debug("CompanyExportTask SetCellValue", "err", err)
			}
		}
	}

	fileName := "/tmp/" + random.Gen(10) + ".xlsx"

	err = workbook.SaveAs(upload.StaticDir + fileName)
	if err != nil {
		return "", err
	}

	if err := workbook.Close(); err != nil {
		slog.Error("CompanyExportTask close workbook", "err", err)
	}

	return fileName, nil
}

func (r *Resolver) CompanyExport(
	ctx context.Context,
	after *entgql.Cursor[uuid.UUID],
	first *int,
	before *entgql.Cursor[uuid.UUID],
	last *int,
	orderBy []*ent.CompanyOrder,
	where *ent.CompanyWhereInput,
	fileType string,
	excelUrl *string,
) (*string, error) {

	_, err := taskQueue.Server.GetRegisteredTask("CompanyExportTask")
	if err != nil {
		return nil, err
	}

	var userId *string = nil

	resource := schema.Company{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}

	if resource.ExportRow == nil {
		return nil, errors.New("Has no export row formatter")
	}

	if !resource.SkipJWTCheck {
		userId, err = jwt.GetCurrentJwtUserID(ctx)
		if err != nil {
			slog.Debug("BottleQuery getJwtUser", "err", err)
			return nil, err
		}
	}

	taskInput := CompanyExportTaskInput{
		After:    after,
		First:    first,
		Before:   before,
		Last:     last,
		Where:    where,
		FileType: fileType,
		ExcelUrl: excelUrl,
		UserId:   userId,
	}

	for _, order := range orderBy {
		taskInput.OrderBy = append(taskInput.OrderBy, OrderByDirectionField{
			Direction: order.Direction.String(),
			Field:     order.Field.String(),
		})
	}

	jsonBytes, err := json.Marshal(taskInput)
	if err != nil {
		return nil, err
	}

	s := tasks.Signature{
		Name: "CompanyExportTask",
		Args: []tasks.Arg{
			{
				Type:  "string",
				Value: string(jsonBytes),
			},
		},
	}

	t := tasks.Signature(s)
	task, err := taskQueue.Server.SendTaskWithContext(ctx, &t)
	if err != nil {
		return nil, err
	}

	taskId := task.Signature.UUID
	return &taskId, nil
}

func (m mutationResolver) CompanyCreate(ctx context.Context, input ent.CreateCompanyInput) (*ent.Company, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "CompanyCreate")
	}
	resource := schema.Company{}.Resource()
	if resource.HasCreatePermission == nil {
		return nil, errors.New("Has no create permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("CompanyCreate getJwtUser", "err", err)
				return nil, err
			}
		}

		var inputs = []*ent.CreateCompanyInput{&input}

		err = resource.HasCreatePermission(ctx, jwtUser, inputs)
		if err != nil {
			return nil, err
		}
		row, err := m.client.Company.Create().SetInput(input).Save(ctx)
		if err == nil && resource.AfterObjectSave != nil {
			go resource.AfterObjectSave(context.WithoutCancel(ctx), []*ent.Company{row}, jwtUser)
		}
		return row, err
	}
}

func (m mutationResolver) CompanyCreateBulk(ctx context.Context, inputs []*ent.CreateCompanyInput) ([]*ent.Company, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "CompanyCreateBulk")
	}
	resource := schema.Company{}.Resource()
	if resource.HasCreatePermission == nil {
		return nil, errors.New("Has no create permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("CompanyCreateBulk getJwtUser", "err", err)
				return nil, err
			}
		}

		err = resource.HasCreatePermission(ctx, jwtUser, inputs)
		if err != nil {
			slog.Debug("CompanyCreateBulk", "err", err)
			return nil, err
		}
		rows, err := m.client.Company.MapCreateBulk(inputs, func(c *ent.CompanyCreate, i int) {
			c.SetInput(*inputs[i])
		}).Save(ctx)
		if err == nil && resource.AfterObjectSave != nil {
			go resource.AfterObjectSave(context.WithoutCancel(ctx), rows, jwtUser)
		}
		return rows, err
	}
}

func (m mutationResolver) CompanyUpdate(ctx context.Context, id uuid.UUID, input ent.UpdateCompanyInput) (*ent.Company, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "CompanyUpdate")
	}
	resource := schema.Company{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}
	if resource.HasUpdatePermission == nil {
		return nil, errors.New("Has no update permission")
	}

	var jwtUser *ent.User
	var err error
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUser(ctx)
		if err != nil {
			return nil, err
		}
	}

	qs := m.client.Company.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		return nil, err
	}

	row, err := qs.Where(company.ID(id)).First(ctx)
	if err != nil {
		slog.Debug("CompanyUpdate Where", "err", err)
		return nil, err
	}

	err = resource.HasUpdatePermission(ctx, jwtUser, row, &input)
	if err != nil {
		return nil, err
	}

	row, err = row.Update().SetInput(input).Save(ctx)
	if err == nil && resource.AfterObjectUpdate != nil {
		go resource.AfterObjectUpdate(context.WithoutCancel(ctx), row, jwtUser)
	}

	return row, err
}

func (m mutationResolver) CompanyDelete(ctx context.Context, id uuid.UUID) (*ent.Company, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "CompanyDelete")
	}
	resource := schema.Company{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}
	if resource.HasDeletePermission == nil {
		return nil, errors.New("Has no delete permission")
	}

	var jwtUser *ent.User
	var err error
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUser(ctx)
		if err != nil {
			return nil, err
		}
	}

	qs := m.client.Company.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		return nil, err
	}

	row, err := qs.Where(company.ID(id)).First(ctx)
	if err != nil {
		return nil, err
	}

	err = resource.HasDeletePermission(ctx, jwtUser, row)
	if err != nil {
		return nil, err
	}

	err = m.client.Company.DeleteOne(row).Exec(ctx)
	return row, err
}

func (r *Resolver) PermissionQuery(
	ctx context.Context,
	after *entgql.Cursor[uuid.UUID],
	first *int,
	before *entgql.Cursor[uuid.UUID],
	last *int,
	orderBy []*ent.PermissionOrder,
	where *ent.PermissionWhereInput,
) (*ent.PermissionConnection, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "PermissionQuery")
	}
	resource := schema.Permission{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("PermissionQuery getJwtUser", "err", err)
				return nil, err
			}
		}

		qs := r.client.Permission.Query()
		err = resource.HasReadPermission(ctx, jwtUser, qs)
		if err != nil {
			slog.Debug("PermissionQuery", "err", err)
			return nil, err
		}
		return qs.Paginate(ctx, after, first, before, last, ent.WithPermissionFilter(where.Filter), ent.WithPermissionOrder(orderBy))
	}
}

type PermissionExportTaskInput struct {
	After    *entgql.Cursor[uuid.UUID]
	First    *int
	Before   *entgql.Cursor[uuid.UUID]
	Last     *int
	OrderBy  []OrderByDirectionField
	Where    *ent.PermissionWhereInput
	FileType string
	ExcelUrl *string
	UserId   *string
}

func PermissionExportTask(
	ctx context.Context,
	input string,
) (string, error) {

	var taskInput PermissionExportTaskInput

	err := json.Unmarshal([]byte(input), &taskInput)
	if err != nil {
		return "", err
	}

	resource := schema.Permission{}.Resource()
	if resource.HasReadPermission == nil {
		return "", errors.New("Has no read permission")
	}

	if resource.ExportRow == nil {
		return "", errors.New("Has no export row formatter")
	}

	var jwtUser *ent.User
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUserById(ctx, taskInput.UserId)
		if err != nil {
			slog.Debug("PermissionQuery getJwtUser", "err", err)
			return "", err
		}
	}

	qs := db.Client.Permission.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		slog.Debug("PermissionQuery", "err", err)
		return "", err
	}
	if resource.ExportPreload != nil {
		err = resource.ExportPreload(ctx, jwtUser, qs)
		if err != nil {
			slog.Debug("PermissionQuery", "err", err)
			return "", err
		}
	}

	var orderBy []*ent.PermissionOrder

	for _, order := range taskInput.OrderBy {
		f := ent.DefaultPermissionOrder
		f.Direction = ent.OrderDirection(order.Direction)
		f.Field.UnmarshalGQL(order.Field)
		orderBy = append(orderBy, f)
	}

	rows, err := qs.Paginate(ctx, taskInput.After,
		taskInput.First,
		taskInput.Before,
		taskInput.Last,
		ent.WithPermissionFilter(taskInput.Where.Filter),
		ent.WithPermissionOrder(orderBy),
	)

	workbook := excelize.NewFile()
	sheetName := "Sheet1"
	if workbook.SheetCount == 0 {
		_, err = workbook.NewSheet(sheetName)
		if err != nil {
			return "", err
		}
	} else {
		sheetName = workbook.GetSheetList()[0]
	}

	if resource.ExportHeaders != nil {
		for i, header := range resource.ExportHeaders {
			// Set value of a cell.
			workbook.SetCellValue(sheetName, fmt.Sprintf("%s%d", string(rune(65+i)), 1), header)
		}
	}

	rowIndex := 1

	for _, edge := range rows.Edges {
		row := resource.ExportRow(ctx, jwtUser, edge.Node)
		if len(row) == 0 {
			continue
		}
		rowIndex += 1
		for i, cell := range row {
			if reflect.ValueOf(cell).Kind().String() == "ptr" {
				if reflect.ValueOf(cell).IsNil() {
					continue
				}
				cell = reflect.ValueOf(cell).Elem().Interface()
			}
			err = workbook.SetCellValue(sheetName, fmt.Sprintf("%s%d", string(rune(65+i)), rowIndex), cell)
			if err != nil {
				slog.Debug("PermissionExportTask SetCellValue", "err", err)
			}
		}
	}

	fileName := "/tmp/" + random.Gen(10) + ".xlsx"

	err = workbook.SaveAs(upload.StaticDir + fileName)
	if err != nil {
		return "", err
	}

	if err := workbook.Close(); err != nil {
		slog.Error("PermissionExportTask close workbook", "err", err)
	}

	return fileName, nil
}

func (r *Resolver) PermissionExport(
	ctx context.Context,
	after *entgql.Cursor[uuid.UUID],
	first *int,
	before *entgql.Cursor[uuid.UUID],
	last *int,
	orderBy []*ent.PermissionOrder,
	where *ent.PermissionWhereInput,
	fileType string,
	excelUrl *string,
) (*string, error) {

	_, err := taskQueue.Server.GetRegisteredTask("PermissionExportTask")
	if err != nil {
		return nil, err
	}

	var userId *string = nil

	resource := schema.Permission{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}

	if resource.ExportRow == nil {
		return nil, errors.New("Has no export row formatter")
	}

	if !resource.SkipJWTCheck {
		userId, err = jwt.GetCurrentJwtUserID(ctx)
		if err != nil {
			slog.Debug("BottleQuery getJwtUser", "err", err)
			return nil, err
		}
	}

	taskInput := PermissionExportTaskInput{
		After:    after,
		First:    first,
		Before:   before,
		Last:     last,
		Where:    where,
		FileType: fileType,
		ExcelUrl: excelUrl,
		UserId:   userId,
	}

	for _, order := range orderBy {
		taskInput.OrderBy = append(taskInput.OrderBy, OrderByDirectionField{
			Direction: order.Direction.String(),
			Field:     order.Field.String(),
		})
	}

	jsonBytes, err := json.Marshal(taskInput)
	if err != nil {
		return nil, err
	}

	s := tasks.Signature{
		Name: "PermissionExportTask",
		Args: []tasks.Arg{
			{
				Type:  "string",
				Value: string(jsonBytes),
			},
		},
	}

	t := tasks.Signature(s)
	task, err := taskQueue.Server.SendTaskWithContext(ctx, &t)
	if err != nil {
		return nil, err
	}

	taskId := task.Signature.UUID
	return &taskId, nil
}

func (m mutationResolver) PermissionCreate(ctx context.Context, input ent.CreatePermissionInput) (*ent.Permission, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "PermissionCreate")
	}
	resource := schema.Permission{}.Resource()
	if resource.HasCreatePermission == nil {
		return nil, errors.New("Has no create permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("PermissionCreate getJwtUser", "err", err)
				return nil, err
			}
		}

		var inputs = []*ent.CreatePermissionInput{&input}

		err = resource.HasCreatePermission(ctx, jwtUser, inputs)
		if err != nil {
			return nil, err
		}
		row, err := m.client.Permission.Create().SetInput(input).Save(ctx)
		if err == nil && resource.AfterObjectSave != nil {
			go resource.AfterObjectSave(context.WithoutCancel(ctx), []*ent.Permission{row}, jwtUser)
		}
		return row, err
	}
}

func (m mutationResolver) PermissionCreateBulk(ctx context.Context, inputs []*ent.CreatePermissionInput) ([]*ent.Permission, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "PermissionCreateBulk")
	}
	resource := schema.Permission{}.Resource()
	if resource.HasCreatePermission == nil {
		return nil, errors.New("Has no create permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("PermissionCreateBulk getJwtUser", "err", err)
				return nil, err
			}
		}

		err = resource.HasCreatePermission(ctx, jwtUser, inputs)
		if err != nil {
			slog.Debug("PermissionCreateBulk", "err", err)
			return nil, err
		}
		rows, err := m.client.Permission.MapCreateBulk(inputs, func(c *ent.PermissionCreate, i int) {
			c.SetInput(*inputs[i])
		}).Save(ctx)
		if err == nil && resource.AfterObjectSave != nil {
			go resource.AfterObjectSave(context.WithoutCancel(ctx), rows, jwtUser)
		}
		return rows, err
	}
}

func (m mutationResolver) PermissionUpdate(ctx context.Context, id uuid.UUID, input ent.UpdatePermissionInput) (*ent.Permission, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "PermissionUpdate")
	}
	resource := schema.Permission{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}
	if resource.HasUpdatePermission == nil {
		return nil, errors.New("Has no update permission")
	}

	var jwtUser *ent.User
	var err error
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUser(ctx)
		if err != nil {
			return nil, err
		}
	}

	qs := m.client.Permission.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		return nil, err
	}

	row, err := qs.Where(permission.ID(id)).First(ctx)
	if err != nil {
		slog.Debug("PermissionUpdate Where", "err", err)
		return nil, err
	}

	err = resource.HasUpdatePermission(ctx, jwtUser, row, &input)
	if err != nil {
		return nil, err
	}

	row, err = row.Update().SetInput(input).Save(ctx)
	if err == nil && resource.AfterObjectUpdate != nil {
		go resource.AfterObjectUpdate(context.WithoutCancel(ctx), row, jwtUser)
	}

	return row, err
}

func (m mutationResolver) PermissionDelete(ctx context.Context, id uuid.UUID) (*ent.Permission, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "PermissionDelete")
	}
	resource := schema.Permission{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}
	if resource.HasDeletePermission == nil {
		return nil, errors.New("Has no delete permission")
	}

	var jwtUser *ent.User
	var err error
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUser(ctx)
		if err != nil {
			return nil, err
		}
	}

	qs := m.client.Permission.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		return nil, err
	}

	row, err := qs.Where(permission.ID(id)).First(ctx)
	if err != nil {
		return nil, err
	}

	err = resource.HasDeletePermission(ctx, jwtUser, row)
	if err != nil {
		return nil, err
	}

	err = m.client.Permission.DeleteOne(row).Exec(ctx)
	return row, err
}

func (r *Resolver) RoleQuery(
	ctx context.Context,
	after *entgql.Cursor[uuid.UUID],
	first *int,
	before *entgql.Cursor[uuid.UUID],
	last *int,
	orderBy []*ent.RoleOrder,
	where *ent.RoleWhereInput,
) (*ent.RoleConnection, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "RoleQuery")
	}
	resource := schema.Role{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("RoleQuery getJwtUser", "err", err)
				return nil, err
			}
		}

		qs := r.client.Role.Query()
		err = resource.HasReadPermission(ctx, jwtUser, qs)
		if err != nil {
			slog.Debug("RoleQuery", "err", err)
			return nil, err
		}
		return qs.Paginate(ctx, after, first, before, last, ent.WithRoleFilter(where.Filter), ent.WithRoleOrder(orderBy))
	}
}

type RoleExportTaskInput struct {
	After    *entgql.Cursor[uuid.UUID]
	First    *int
	Before   *entgql.Cursor[uuid.UUID]
	Last     *int
	OrderBy  []OrderByDirectionField
	Where    *ent.RoleWhereInput
	FileType string
	ExcelUrl *string
	UserId   *string
}

func RoleExportTask(
	ctx context.Context,
	input string,
) (string, error) {

	var taskInput RoleExportTaskInput

	err := json.Unmarshal([]byte(input), &taskInput)
	if err != nil {
		return "", err
	}

	resource := schema.Role{}.Resource()
	if resource.HasReadPermission == nil {
		return "", errors.New("Has no read permission")
	}

	if resource.ExportRow == nil {
		return "", errors.New("Has no export row formatter")
	}

	var jwtUser *ent.User
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUserById(ctx, taskInput.UserId)
		if err != nil {
			slog.Debug("RoleQuery getJwtUser", "err", err)
			return "", err
		}
	}

	qs := db.Client.Role.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		slog.Debug("RoleQuery", "err", err)
		return "", err
	}
	if resource.ExportPreload != nil {
		err = resource.ExportPreload(ctx, jwtUser, qs)
		if err != nil {
			slog.Debug("RoleQuery", "err", err)
			return "", err
		}
	}

	var orderBy []*ent.RoleOrder

	for _, order := range taskInput.OrderBy {
		f := ent.DefaultRoleOrder
		f.Direction = ent.OrderDirection(order.Direction)
		f.Field.UnmarshalGQL(order.Field)
		orderBy = append(orderBy, f)
	}

	rows, err := qs.Paginate(ctx, taskInput.After,
		taskInput.First,
		taskInput.Before,
		taskInput.Last,
		ent.WithRoleFilter(taskInput.Where.Filter),
		ent.WithRoleOrder(orderBy),
	)

	workbook := excelize.NewFile()
	sheetName := "Sheet1"
	if workbook.SheetCount == 0 {
		_, err = workbook.NewSheet(sheetName)
		if err != nil {
			return "", err
		}
	} else {
		sheetName = workbook.GetSheetList()[0]
	}

	if resource.ExportHeaders != nil {
		for i, header := range resource.ExportHeaders {
			// Set value of a cell.
			workbook.SetCellValue(sheetName, fmt.Sprintf("%s%d", string(rune(65+i)), 1), header)
		}
	}

	rowIndex := 1

	for _, edge := range rows.Edges {
		row := resource.ExportRow(ctx, jwtUser, edge.Node)
		if len(row) == 0 {
			continue
		}
		rowIndex += 1
		for i, cell := range row {
			if reflect.ValueOf(cell).Kind().String() == "ptr" {
				if reflect.ValueOf(cell).IsNil() {
					continue
				}
				cell = reflect.ValueOf(cell).Elem().Interface()
			}
			err = workbook.SetCellValue(sheetName, fmt.Sprintf("%s%d", string(rune(65+i)), rowIndex), cell)
			if err != nil {
				slog.Debug("RoleExportTask SetCellValue", "err", err)
			}
		}
	}

	fileName := "/tmp/" + random.Gen(10) + ".xlsx"

	err = workbook.SaveAs(upload.StaticDir + fileName)
	if err != nil {
		return "", err
	}

	if err := workbook.Close(); err != nil {
		slog.Error("RoleExportTask close workbook", "err", err)
	}

	return fileName, nil
}

func (r *Resolver) RoleExport(
	ctx context.Context,
	after *entgql.Cursor[uuid.UUID],
	first *int,
	before *entgql.Cursor[uuid.UUID],
	last *int,
	orderBy []*ent.RoleOrder,
	where *ent.RoleWhereInput,
	fileType string,
	excelUrl *string,
) (*string, error) {

	_, err := taskQueue.Server.GetRegisteredTask("RoleExportTask")
	if err != nil {
		return nil, err
	}

	var userId *string = nil

	resource := schema.Role{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}

	if resource.ExportRow == nil {
		return nil, errors.New("Has no export row formatter")
	}

	if !resource.SkipJWTCheck {
		userId, err = jwt.GetCurrentJwtUserID(ctx)
		if err != nil {
			slog.Debug("BottleQuery getJwtUser", "err", err)
			return nil, err
		}
	}

	taskInput := RoleExportTaskInput{
		After:    after,
		First:    first,
		Before:   before,
		Last:     last,
		Where:    where,
		FileType: fileType,
		ExcelUrl: excelUrl,
		UserId:   userId,
	}

	for _, order := range orderBy {
		taskInput.OrderBy = append(taskInput.OrderBy, OrderByDirectionField{
			Direction: order.Direction.String(),
			Field:     order.Field.String(),
		})
	}

	jsonBytes, err := json.Marshal(taskInput)
	if err != nil {
		return nil, err
	}

	s := tasks.Signature{
		Name: "RoleExportTask",
		Args: []tasks.Arg{
			{
				Type:  "string",
				Value: string(jsonBytes),
			},
		},
	}

	t := tasks.Signature(s)
	task, err := taskQueue.Server.SendTaskWithContext(ctx, &t)
	if err != nil {
		return nil, err
	}

	taskId := task.Signature.UUID
	return &taskId, nil
}

func (m mutationResolver) RoleCreate(ctx context.Context, input ent.CreateRoleInput) (*ent.Role, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "RoleCreate")
	}
	resource := schema.Role{}.Resource()
	if resource.HasCreatePermission == nil {
		return nil, errors.New("Has no create permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("RoleCreate getJwtUser", "err", err)
				return nil, err
			}
		}

		var inputs = []*ent.CreateRoleInput{&input}

		err = resource.HasCreatePermission(ctx, jwtUser, inputs)
		if err != nil {
			return nil, err
		}
		row, err := m.client.Role.Create().SetInput(input).Save(ctx)
		if err == nil && resource.AfterObjectSave != nil {
			go resource.AfterObjectSave(context.WithoutCancel(ctx), []*ent.Role{row}, jwtUser)
		}
		return row, err
	}
}

func (m mutationResolver) RoleCreateBulk(ctx context.Context, inputs []*ent.CreateRoleInput) ([]*ent.Role, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "RoleCreateBulk")
	}
	resource := schema.Role{}.Resource()
	if resource.HasCreatePermission == nil {
		return nil, errors.New("Has no create permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("RoleCreateBulk getJwtUser", "err", err)
				return nil, err
			}
		}

		err = resource.HasCreatePermission(ctx, jwtUser, inputs)
		if err != nil {
			slog.Debug("RoleCreateBulk", "err", err)
			return nil, err
		}
		rows, err := m.client.Role.MapCreateBulk(inputs, func(c *ent.RoleCreate, i int) {
			c.SetInput(*inputs[i])
		}).Save(ctx)
		if err == nil && resource.AfterObjectSave != nil {
			go resource.AfterObjectSave(context.WithoutCancel(ctx), rows, jwtUser)
		}
		return rows, err
	}
}

func (m mutationResolver) RoleUpdate(ctx context.Context, id uuid.UUID, input ent.UpdateRoleInput) (*ent.Role, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "RoleUpdate")
	}
	resource := schema.Role{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}
	if resource.HasUpdatePermission == nil {
		return nil, errors.New("Has no update permission")
	}

	var jwtUser *ent.User
	var err error
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUser(ctx)
		if err != nil {
			return nil, err
		}
	}

	qs := m.client.Role.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		return nil, err
	}

	row, err := qs.Where(role.ID(id)).First(ctx)
	if err != nil {
		slog.Debug("RoleUpdate Where", "err", err)
		return nil, err
	}

	err = resource.HasUpdatePermission(ctx, jwtUser, row, &input)
	if err != nil {
		return nil, err
	}

	row, err = row.Update().SetInput(input).Save(ctx)
	if err == nil && resource.AfterObjectUpdate != nil {
		go resource.AfterObjectUpdate(context.WithoutCancel(ctx), row, jwtUser)
	}

	return row, err
}

func (m mutationResolver) RoleDelete(ctx context.Context, id uuid.UUID) (*ent.Role, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "RoleDelete")
	}
	resource := schema.Role{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}
	if resource.HasDeletePermission == nil {
		return nil, errors.New("Has no delete permission")
	}

	var jwtUser *ent.User
	var err error
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUser(ctx)
		if err != nil {
			return nil, err
		}
	}

	qs := m.client.Role.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		return nil, err
	}

	row, err := qs.Where(role.ID(id)).First(ctx)
	if err != nil {
		return nil, err
	}

	err = resource.HasDeletePermission(ctx, jwtUser, row)
	if err != nil {
		return nil, err
	}

	err = m.client.Role.DeleteOne(row).Exec(ctx)
	return row, err
}

func (r *Resolver) RolePermissionQuery(
	ctx context.Context,
	after *entgql.Cursor[uuid.UUID],
	first *int,
	before *entgql.Cursor[uuid.UUID],
	last *int,
	orderBy []*ent.RolePermissionOrder,
	where *ent.RolePermissionWhereInput,
) (*ent.RolePermissionConnection, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "RolePermissionQuery")
	}
	resource := schema.RolePermission{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("RolePermissionQuery getJwtUser", "err", err)
				return nil, err
			}
		}

		qs := r.client.RolePermission.Query()
		err = resource.HasReadPermission(ctx, jwtUser, qs)
		if err != nil {
			slog.Debug("RolePermissionQuery", "err", err)
			return nil, err
		}
		return qs.Paginate(ctx, after, first, before, last, ent.WithRolePermissionFilter(where.Filter), ent.WithRolePermissionOrder(orderBy))
	}
}

type RolePermissionExportTaskInput struct {
	After    *entgql.Cursor[uuid.UUID]
	First    *int
	Before   *entgql.Cursor[uuid.UUID]
	Last     *int
	OrderBy  []OrderByDirectionField
	Where    *ent.RolePermissionWhereInput
	FileType string
	ExcelUrl *string
	UserId   *string
}

func RolePermissionExportTask(
	ctx context.Context,
	input string,
) (string, error) {

	var taskInput RolePermissionExportTaskInput

	err := json.Unmarshal([]byte(input), &taskInput)
	if err != nil {
		return "", err
	}

	resource := schema.RolePermission{}.Resource()
	if resource.HasReadPermission == nil {
		return "", errors.New("Has no read permission")
	}

	if resource.ExportRow == nil {
		return "", errors.New("Has no export row formatter")
	}

	var jwtUser *ent.User
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUserById(ctx, taskInput.UserId)
		if err != nil {
			slog.Debug("RolePermissionQuery getJwtUser", "err", err)
			return "", err
		}
	}

	qs := db.Client.RolePermission.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		slog.Debug("RolePermissionQuery", "err", err)
		return "", err
	}
	if resource.ExportPreload != nil {
		err = resource.ExportPreload(ctx, jwtUser, qs)
		if err != nil {
			slog.Debug("RolePermissionQuery", "err", err)
			return "", err
		}
	}

	var orderBy []*ent.RolePermissionOrder

	for _, order := range taskInput.OrderBy {
		f := ent.DefaultRolePermissionOrder
		f.Direction = ent.OrderDirection(order.Direction)
		f.Field.UnmarshalGQL(order.Field)
		orderBy = append(orderBy, f)
	}

	rows, err := qs.Paginate(ctx, taskInput.After,
		taskInput.First,
		taskInput.Before,
		taskInput.Last,
		ent.WithRolePermissionFilter(taskInput.Where.Filter),
		ent.WithRolePermissionOrder(orderBy),
	)

	workbook := excelize.NewFile()
	sheetName := "Sheet1"
	if workbook.SheetCount == 0 {
		_, err = workbook.NewSheet(sheetName)
		if err != nil {
			return "", err
		}
	} else {
		sheetName = workbook.GetSheetList()[0]
	}

	if resource.ExportHeaders != nil {
		for i, header := range resource.ExportHeaders {
			// Set value of a cell.
			workbook.SetCellValue(sheetName, fmt.Sprintf("%s%d", string(rune(65+i)), 1), header)
		}
	}

	rowIndex := 1

	for _, edge := range rows.Edges {
		row := resource.ExportRow(ctx, jwtUser, edge.Node)
		if len(row) == 0 {
			continue
		}
		rowIndex += 1
		for i, cell := range row {
			if reflect.ValueOf(cell).Kind().String() == "ptr" {
				if reflect.ValueOf(cell).IsNil() {
					continue
				}
				cell = reflect.ValueOf(cell).Elem().Interface()
			}
			err = workbook.SetCellValue(sheetName, fmt.Sprintf("%s%d", string(rune(65+i)), rowIndex), cell)
			if err != nil {
				slog.Debug("RolePermissionExportTask SetCellValue", "err", err)
			}
		}
	}

	fileName := "/tmp/" + random.Gen(10) + ".xlsx"

	err = workbook.SaveAs(upload.StaticDir + fileName)
	if err != nil {
		return "", err
	}

	if err := workbook.Close(); err != nil {
		slog.Error("RolePermissionExportTask close workbook", "err", err)
	}

	return fileName, nil
}

func (r *Resolver) RolePermissionExport(
	ctx context.Context,
	after *entgql.Cursor[uuid.UUID],
	first *int,
	before *entgql.Cursor[uuid.UUID],
	last *int,
	orderBy []*ent.RolePermissionOrder,
	where *ent.RolePermissionWhereInput,
	fileType string,
	excelUrl *string,
) (*string, error) {

	_, err := taskQueue.Server.GetRegisteredTask("RolePermissionExportTask")
	if err != nil {
		return nil, err
	}

	var userId *string = nil

	resource := schema.RolePermission{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}

	if resource.ExportRow == nil {
		return nil, errors.New("Has no export row formatter")
	}

	if !resource.SkipJWTCheck {
		userId, err = jwt.GetCurrentJwtUserID(ctx)
		if err != nil {
			slog.Debug("BottleQuery getJwtUser", "err", err)
			return nil, err
		}
	}

	taskInput := RolePermissionExportTaskInput{
		After:    after,
		First:    first,
		Before:   before,
		Last:     last,
		Where:    where,
		FileType: fileType,
		ExcelUrl: excelUrl,
		UserId:   userId,
	}

	for _, order := range orderBy {
		taskInput.OrderBy = append(taskInput.OrderBy, OrderByDirectionField{
			Direction: order.Direction.String(),
			Field:     order.Field.String(),
		})
	}

	jsonBytes, err := json.Marshal(taskInput)
	if err != nil {
		return nil, err
	}

	s := tasks.Signature{
		Name: "RolePermissionExportTask",
		Args: []tasks.Arg{
			{
				Type:  "string",
				Value: string(jsonBytes),
			},
		},
	}

	t := tasks.Signature(s)
	task, err := taskQueue.Server.SendTaskWithContext(ctx, &t)
	if err != nil {
		return nil, err
	}

	taskId := task.Signature.UUID
	return &taskId, nil
}

func (m mutationResolver) RolePermissionCreate(ctx context.Context, input ent.CreateRolePermissionInput) (*ent.RolePermission, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "RolePermissionCreate")
	}
	resource := schema.RolePermission{}.Resource()
	if resource.HasCreatePermission == nil {
		return nil, errors.New("Has no create permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("RolePermissionCreate getJwtUser", "err", err)
				return nil, err
			}
		}

		var inputs = []*ent.CreateRolePermissionInput{&input}

		err = resource.HasCreatePermission(ctx, jwtUser, inputs)
		if err != nil {
			return nil, err
		}
		row, err := m.client.RolePermission.Create().SetInput(input).Save(ctx)
		if err == nil && resource.AfterObjectSave != nil {
			go resource.AfterObjectSave(context.WithoutCancel(ctx), []*ent.RolePermission{row}, jwtUser)
		}
		return row, err
	}
}

func (m mutationResolver) RolePermissionCreateBulk(ctx context.Context, inputs []*ent.CreateRolePermissionInput) ([]*ent.RolePermission, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "RolePermissionCreateBulk")
	}
	resource := schema.RolePermission{}.Resource()
	if resource.HasCreatePermission == nil {
		return nil, errors.New("Has no create permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("RolePermissionCreateBulk getJwtUser", "err", err)
				return nil, err
			}
		}

		err = resource.HasCreatePermission(ctx, jwtUser, inputs)
		if err != nil {
			slog.Debug("RolePermissionCreateBulk", "err", err)
			return nil, err
		}
		rows, err := m.client.RolePermission.MapCreateBulk(inputs, func(c *ent.RolePermissionCreate, i int) {
			c.SetInput(*inputs[i])
		}).Save(ctx)
		if err == nil && resource.AfterObjectSave != nil {
			go resource.AfterObjectSave(context.WithoutCancel(ctx), rows, jwtUser)
		}
		return rows, err
	}
}

func (m mutationResolver) RolePermissionUpdate(ctx context.Context, id uuid.UUID, input ent.UpdateRolePermissionInput) (*ent.RolePermission, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "RolePermissionUpdate")
	}
	resource := schema.RolePermission{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}
	if resource.HasUpdatePermission == nil {
		return nil, errors.New("Has no update permission")
	}

	var jwtUser *ent.User
	var err error
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUser(ctx)
		if err != nil {
			return nil, err
		}
	}

	qs := m.client.RolePermission.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		return nil, err
	}

	row, err := qs.Where(rolepermission.ID(id)).First(ctx)
	if err != nil {
		slog.Debug("RolePermissionUpdate Where", "err", err)
		return nil, err
	}

	err = resource.HasUpdatePermission(ctx, jwtUser, row, &input)
	if err != nil {
		return nil, err
	}

	row, err = row.Update().SetInput(input).Save(ctx)
	if err == nil && resource.AfterObjectUpdate != nil {
		go resource.AfterObjectUpdate(context.WithoutCancel(ctx), row, jwtUser)
	}

	return row, err
}

func (m mutationResolver) RolePermissionDelete(ctx context.Context, id uuid.UUID) (*ent.RolePermission, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "RolePermissionDelete")
	}
	resource := schema.RolePermission{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}
	if resource.HasDeletePermission == nil {
		return nil, errors.New("Has no delete permission")
	}

	var jwtUser *ent.User
	var err error
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUser(ctx)
		if err != nil {
			return nil, err
		}
	}

	qs := m.client.RolePermission.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		return nil, err
	}

	row, err := qs.Where(rolepermission.ID(id)).First(ctx)
	if err != nil {
		return nil, err
	}

	err = resource.HasDeletePermission(ctx, jwtUser, row)
	if err != nil {
		return nil, err
	}

	err = m.client.RolePermission.DeleteOne(row).Exec(ctx)
	return row, err
}

func (r *Resolver) UserQuery(
	ctx context.Context,
	after *entgql.Cursor[uuid.UUID],
	first *int,
	before *entgql.Cursor[uuid.UUID],
	last *int,
	orderBy []*ent.UserOrder,
	where *ent.UserWhereInput,
) (*ent.UserConnection, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "UserQuery")
	}
	resource := schema.User{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("UserQuery getJwtUser", "err", err)
				return nil, err
			}
		}

		qs := r.client.User.Query()
		err = resource.HasReadPermission(ctx, jwtUser, qs)
		if err != nil {
			slog.Debug("UserQuery", "err", err)
			return nil, err
		}
		return qs.Paginate(ctx, after, first, before, last, ent.WithUserFilter(where.Filter), ent.WithUserOrder(orderBy))
	}
}

type UserExportTaskInput struct {
	After    *entgql.Cursor[uuid.UUID]
	First    *int
	Before   *entgql.Cursor[uuid.UUID]
	Last     *int
	OrderBy  []OrderByDirectionField
	Where    *ent.UserWhereInput
	FileType string
	ExcelUrl *string
	UserId   *string
}

func UserExportTask(
	ctx context.Context,
	input string,
) (string, error) {

	var taskInput UserExportTaskInput

	err := json.Unmarshal([]byte(input), &taskInput)
	if err != nil {
		return "", err
	}

	resource := schema.User{}.Resource()
	if resource.HasReadPermission == nil {
		return "", errors.New("Has no read permission")
	}

	if resource.ExportRow == nil {
		return "", errors.New("Has no export row formatter")
	}

	var jwtUser *ent.User
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUserById(ctx, taskInput.UserId)
		if err != nil {
			slog.Debug("UserQuery getJwtUser", "err", err)
			return "", err
		}
	}

	qs := db.Client.User.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		slog.Debug("UserQuery", "err", err)
		return "", err
	}
	if resource.ExportPreload != nil {
		err = resource.ExportPreload(ctx, jwtUser, qs)
		if err != nil {
			slog.Debug("UserQuery", "err", err)
			return "", err
		}
	}

	var orderBy []*ent.UserOrder

	for _, order := range taskInput.OrderBy {
		f := ent.DefaultUserOrder
		f.Direction = ent.OrderDirection(order.Direction)
		f.Field.UnmarshalGQL(order.Field)
		orderBy = append(orderBy, f)
	}

	rows, err := qs.Paginate(ctx, taskInput.After,
		taskInput.First,
		taskInput.Before,
		taskInput.Last,
		ent.WithUserFilter(taskInput.Where.Filter),
		ent.WithUserOrder(orderBy),
	)

	workbook := excelize.NewFile()
	sheetName := "Sheet1"
	if workbook.SheetCount == 0 {
		_, err = workbook.NewSheet(sheetName)
		if err != nil {
			return "", err
		}
	} else {
		sheetName = workbook.GetSheetList()[0]
	}

	if resource.ExportHeaders != nil {
		for i, header := range resource.ExportHeaders {
			// Set value of a cell.
			workbook.SetCellValue(sheetName, fmt.Sprintf("%s%d", string(rune(65+i)), 1), header)
		}
	}

	rowIndex := 1

	for _, edge := range rows.Edges {
		row := resource.ExportRow(ctx, jwtUser, edge.Node)
		if len(row) == 0 {
			continue
		}
		rowIndex += 1
		for i, cell := range row {
			if reflect.ValueOf(cell).Kind().String() == "ptr" {
				if reflect.ValueOf(cell).IsNil() {
					continue
				}
				cell = reflect.ValueOf(cell).Elem().Interface()
			}
			err = workbook.SetCellValue(sheetName, fmt.Sprintf("%s%d", string(rune(65+i)), rowIndex), cell)
			if err != nil {
				slog.Debug("UserExportTask SetCellValue", "err", err)
			}
		}
	}

	fileName := "/tmp/" + random.Gen(10) + ".xlsx"

	err = workbook.SaveAs(upload.StaticDir + fileName)
	if err != nil {
		return "", err
	}

	if err := workbook.Close(); err != nil {
		slog.Error("UserExportTask close workbook", "err", err)
	}

	return fileName, nil
}

func (r *Resolver) UserExport(
	ctx context.Context,
	after *entgql.Cursor[uuid.UUID],
	first *int,
	before *entgql.Cursor[uuid.UUID],
	last *int,
	orderBy []*ent.UserOrder,
	where *ent.UserWhereInput,
	fileType string,
	excelUrl *string,
) (*string, error) {

	_, err := taskQueue.Server.GetRegisteredTask("UserExportTask")
	if err != nil {
		return nil, err
	}

	var userId *string = nil

	resource := schema.User{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}

	if resource.ExportRow == nil {
		return nil, errors.New("Has no export row formatter")
	}

	if !resource.SkipJWTCheck {
		userId, err = jwt.GetCurrentJwtUserID(ctx)
		if err != nil {
			slog.Debug("BottleQuery getJwtUser", "err", err)
			return nil, err
		}
	}

	taskInput := UserExportTaskInput{
		After:    after,
		First:    first,
		Before:   before,
		Last:     last,
		Where:    where,
		FileType: fileType,
		ExcelUrl: excelUrl,
		UserId:   userId,
	}

	for _, order := range orderBy {
		taskInput.OrderBy = append(taskInput.OrderBy, OrderByDirectionField{
			Direction: order.Direction.String(),
			Field:     order.Field.String(),
		})
	}

	jsonBytes, err := json.Marshal(taskInput)
	if err != nil {
		return nil, err
	}

	s := tasks.Signature{
		Name: "UserExportTask",
		Args: []tasks.Arg{
			{
				Type:  "string",
				Value: string(jsonBytes),
			},
		},
	}

	t := tasks.Signature(s)
	task, err := taskQueue.Server.SendTaskWithContext(ctx, &t)
	if err != nil {
		return nil, err
	}

	taskId := task.Signature.UUID
	return &taskId, nil
}

func (m mutationResolver) UserCreate(ctx context.Context, input ent.CreateUserInput) (*ent.User, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "UserCreate")
	}
	resource := schema.User{}.Resource()
	if resource.HasCreatePermission == nil {
		return nil, errors.New("Has no create permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("UserCreate getJwtUser", "err", err)
				return nil, err
			}
		}

		var inputs = []*ent.CreateUserInput{&input}

		err = resource.HasCreatePermission(ctx, jwtUser, inputs)
		if err != nil {
			return nil, err
		}
		row, err := m.client.User.Create().SetInput(input).Save(ctx)
		if err == nil && resource.AfterObjectSave != nil {
			go resource.AfterObjectSave(context.WithoutCancel(ctx), []*ent.User{row}, jwtUser)
		}
		return row, err
	}
}

func (m mutationResolver) UserCreateBulk(ctx context.Context, inputs []*ent.CreateUserInput) ([]*ent.User, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "UserCreateBulk")
	}
	resource := schema.User{}.Resource()
	if resource.HasCreatePermission == nil {
		return nil, errors.New("Has no create permission")
	} else {
		var jwtUser *ent.User
		var err error
		if !resource.SkipJWTCheck {
			jwtUser, err = getJwtUser(ctx)
			if err != nil {
				slog.Debug("UserCreateBulk getJwtUser", "err", err)
				return nil, err
			}
		}

		err = resource.HasCreatePermission(ctx, jwtUser, inputs)
		if err != nil {
			slog.Debug("UserCreateBulk", "err", err)
			return nil, err
		}
		rows, err := m.client.User.MapCreateBulk(inputs, func(c *ent.UserCreate, i int) {
			c.SetInput(*inputs[i])
		}).Save(ctx)
		if err == nil && resource.AfterObjectSave != nil {
			go resource.AfterObjectSave(context.WithoutCancel(ctx), rows, jwtUser)
		}
		return rows, err
	}
}

func (m mutationResolver) UserUpdate(ctx context.Context, id uuid.UUID, input ent.UpdateUserInput) (*ent.User, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "UserUpdate")
	}
	resource := schema.User{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}
	if resource.HasUpdatePermission == nil {
		return nil, errors.New("Has no update permission")
	}

	var jwtUser *ent.User
	var err error
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUser(ctx)
		if err != nil {
			return nil, err
		}
	}

	qs := m.client.User.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		return nil, err
	}

	row, err := qs.Where(user.ID(id)).First(ctx)
	if err != nil {
		slog.Debug("UserUpdate Where", "err", err)
		return nil, err
	}

	err = resource.HasUpdatePermission(ctx, jwtUser, row, &input)
	if err != nil {
		return nil, err
	}

	row, err = row.Update().SetInput(input).Save(ctx)
	if err == nil && resource.AfterObjectUpdate != nil {
		go resource.AfterObjectUpdate(context.WithoutCancel(ctx), row, jwtUser)
	}

	return row, err
}

func (m mutationResolver) UserDelete(ctx context.Context, id uuid.UUID) (*ent.User, error) {
	if resolverName, ok := ctx.Value("ResolverSpanNames").(*apm.ResolverSpanNames); ok {
		resolverName.Names = append(resolverName.Names, "UserDelete")
	}
	resource := schema.User{}.Resource()
	if resource.HasReadPermission == nil {
		return nil, errors.New("Has no read permission")
	}
	if resource.HasDeletePermission == nil {
		return nil, errors.New("Has no delete permission")
	}

	var jwtUser *ent.User
	var err error
	if !resource.SkipJWTCheck {
		jwtUser, err = getJwtUser(ctx)
		if err != nil {
			return nil, err
		}
	}

	qs := m.client.User.Query()
	err = resource.HasReadPermission(ctx, jwtUser, qs)
	if err != nil {
		return nil, err
	}

	row, err := qs.Where(user.ID(id)).First(ctx)
	if err != nil {
		return nil, err
	}

	err = resource.HasDeletePermission(ctx, jwtUser, row)
	if err != nil {
		return nil, err
	}

	err = m.client.User.DeleteOne(row).Exec(ctx)
	return row, err
}
